## Shell开发

之前在debug模块中已经实现了一个简单的shell，可以输入hello、help、game三个指令，

当然这些指令均是在内核态实现的，平常我们使用的shell应该均工作在用户态，主要由用户输入指令，然后指令通过系统调用传输到内核态，处理指令相应的动作，返回用户态等几个操作组成。

目前比较复杂的点是：我们写的代码均是处于内核态，只能申请用户态的内存

解决思路：根据目前这样的情况，我觉得可以像init部分那样，直接在内核中写一部分用户代码，然后放在设定的物理内存以及虚拟内存中（需考虑映射问题），一直写到用户进行系统调用为止（int 0x80），然后注意一下设置用户级堆栈，暂时先想这么多吧。

1、将有关系统调用全部单独拿出来放在user目录下

想到一个问题，ld脚本中定义的符号怎么使用，

![image-20201210141746062](shell开发.assets/image-20201210141746062.png)

![image-20201210141802361](shell开发.assets/image-20201210141802361.png)

该值本身为0，不占内存空间，只是指向了一个地址，所以取其地址才是实际值。

2、设定地址和映射关系。

![image-20201210162817621](shell开发.assets/image-20201210162817621.png)

3、运行user下的用户程序

出现了个小bug

![image-20201210180204522](shell开发.assets/image-20201210180204522.png)

实际内存中没有数据，在物理内存中调一下吧

还是boot中有点问题，最大只能支持28位物理内存？调一下

猜想：insl指令无法访问32位地址？

已经将硬盘中数据读入对应内存中,感觉像是超过0xC0000000不能映射？

![image-20201211114727013](shell开发.assets/image-20201211114727013.png)

好吧，就这样,

![image-20201211115111247](shell开发.assets/image-20201211115111247.png)

![image-20201211115139940](shell开发.assets/image-20201211115139940.png)

既然我们是2G内存，那么用户空间从0x40000000开始吧，然后超过3G的虚拟地址就只使用低28位映射



OK前面的准备工作基本完成，现在还缺少一个东西，就是用户作为一个进程，一直在运行shell脚本，当输入一个命令时，按下回车符，内核需要读取到这个命令，这个过程也需要一个系统调用完成。

#### 2020.12.12

遇到个BUG，SWITCH语句在编译成汇编代码时，会做一个跳转表，这应该属于rodata段，目前只映射了text段和data段

通过ld脚本指定文件区分用户代码和内核代码

![image-20201212133824917](shell开发.assets/image-20201212133824917.png)

链接器只会链接一个文件，所以之前已经链接的文件，后面就不需要剔除





当用户输入字符时才应该响应系统调用，若没输入则一直等待，先试试之前的锁有用没

遇到个BUG，正常调用时寄存器值：

![image-20201214094952276](shell开发.assets/image-20201214094952276.png)

![image-20201214095401220](shell开发.assets/image-20201214095401220.png)

不正常时

![image-20201214101253092](shell开发.assets/image-20201214101253092.png)

![image-20201214101216810](shell开发.assets/image-20201214101216810.png)

14

找到原因了，用户进程的内核栈和它自己用的栈搞混了，所以在中断处理程序中会破坏它自己的栈信息，就回不到原点，还有个问题是用户进程先运行的时候，进行系统调用时可以切换到内核栈，后面再进行进程切换后，就无法回到内核栈。

是这样的，用户进程运行的时候，是强制让它执行，没有走task_run流程，所以内核栈就没改成用户的 内核栈，还是原来系统的内核栈，但第二次进程调度时候切换内核栈，这时候就会暴露出用户进程的内核栈和用户栈相冲突的问题。



遇到个小问题，user目录下的bss段好像没有映射到40000000开始的范围。。，感觉ld脚本有点问题，于是改了下，bss段和data段不映射在一起，解决了。。。真是天天在写BUG，吐了

![image-20201214184910842](shell开发.assets/image-20201214184910842.png)

![image-20201214184902024](shell开发.assets/image-20201214184902024.png)

![image-20201214184928696](shell开发.assets/image-20201214184928696.png)



mark下待做任务，完善键盘输入其他字符的问题，实现退格功能



写完了，不能摸鱼了，该干活了！



#### 2020.12.17

页表有个BUG在，就是分配和释放的内存一直是内核进程的页表，用户进程页表并未实时跟新，所以在用户之后申请的内存都无法存进页表，会导致缺页。算了，早点改下吧，迟早要改。

目前的想法是在malloc和free系统调用中直接复制内核页表。

目前有个奇怪BUG，当时钟中断产生时，用户进程会一直跑，就会一直fork出新进程，好像用户进程的EIP没有改变一样，。



之前一个用户进程，一个内核进程

首先用户进程运行，然后调用sys_read，信号量减1，进程变成停止状态，等待信号量，进行调度，将当前寄存器信息保存到context中,sys_read中调用schedule的下一行，运行内核进程。

貌似懂了，进程切换不能由时钟来执行，系统调用要赶快切换，不然就回不去。



关键问题，用户进程进行fork系统调用后，该进程的中断栈的EIP未发生变化，按理说应指向系统调用下一行。

还是内核栈的问题

感觉还是用户进程产生中断时，硬件没有自动切换esp0？



分析下原因，如果创建完用户进程后，



直接跳转到用户进程,jmp __alltarget，寄存器

![image-20201218121235555](shell开发.assets/image-20201218121235555.png)

直接运行用户进程 task_run

![image-20201218121455968](shell开发.assets/image-20201218121455968.png)

中断栈（内核栈）会覆盖用户栈？确实会





![image-20201220104705559](shell开发.assets/image-20201220104705559.png)

![image-20201220110111956](shell开发.assets/image-20201220110111956.png)

调度后的task

![image-20201220105407188](shell开发.assets/image-20201220105407188.png)

![image-20201220105828910](shell开发.assets/image-20201220105828910.png)



数据被洗了，或者说没映射好，看下什么时候改的。

最后发现是segment_load中的sys_mmap改的。

![image-20201220113400355](shell开发.assets/image-20201220113400355.png)

之前写的有点问题，应该直接从虚拟地址找页表项，然后页目录项和页表二维数组的一维下标是一一对应的。



有问题的栈

![](shell开发.assets/image-20201224122944221.png)

正常栈

![image-20201224123224878](shell开发.assets/image-20201224123224878.png)

查看什么时候修改的,问题找到了，子进程fork返回后仍然使用了父进程的栈，按理应该使用自己的栈，应该是0xf8029f84

![image-20201224125320840](shell开发.assets/image-20201224125320840.png)

这应该是个隐藏的BUG，子进程虽然复制父进程的用户栈，但实际上中断函数返回的时候会返回一个ESP，这个ESP是父进程的ESP

![image-20201227145031868](shell开发.assets/image-20201227145031868.png)

![image-20201227145054871](shell开发.assets/image-20201227145054871.png)